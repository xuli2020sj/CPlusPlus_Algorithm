## 关键字

const

1. 它是一个类型修饰符，可以给任何对象附加上“只读”属性，保证安全；

2. 修饰引用和指针，“const &”可以引用任何类型，是函数入口参数的最佳类型；
3. 修饰成员函数，表示函数是“只读”的，const 对象只能调用 const 成员函数。

volatile

1. 禁止编译器优化，每次从内存中读取数据。

2. 解决 "硬件映射到内存上..." 的问题，不可用于多线程

mutable



变量、函数名和名字空间用 snake_case，全局变量加“g_”前缀；自定义类名用 CamelCase，成员函数用 snake_case，成员变量加“m_”前缀；宏和常量应当全大写，单词之间用下划线连接；尽量不要用下划线作为变量的前缀或者后缀（比如 _local、name_），很难识别。

lambda
1. 捕获”外部变量

# 内存

c语言内存布局图
High Address +-------------------------+
↑         | Command-line arguments  |
|         | & environment variables |
|         +-------------------------+
|         |        Stack area       |
|         |            |            |
|         |            |            |
|         |            ↓            |
|         +-------------------------+
|         |            ↑            |
|         |            |            |
|         |            |            |
|         |        Heap area        |
|         +-------------------------+
|         |   uninitialized data    | // BSS (Block Started by Symbol) Segment
|         +-------------------------+
|         |    initialized data     | // Data Segment
|         +-------------------------+
|         |    code/text segment    |
Low Address  +-------------------------+

## 基本概念
静态存储区既不是堆也不是栈，程序编译、链接时完全确定下来的，具有固定的存储位置

堆，动态分配内存的区域。
1. 具有更高的灵活性，但容易出现内存泄漏
2. 对象很大，大小在编译时不能确定，不应该使用对象值返回

栈，函数调用过程中产生的本地变量和调用数据的区域。

凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。

RAII，C++ 所特有的资源管理方式。
1. 基于栈和析构函数


## STL
### Vector
1. 尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升。
### list
另外一个需要注意的地方是，因为某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：mergeremoveremove_ifreversesortunique
